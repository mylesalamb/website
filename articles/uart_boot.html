---
title: UART Bootloading for the Raspberry Pi
name: tauos_article_1
tags: article
short_description: Writing a hosted bootloader for bare metal Raspberry Pi Development
---
<h3>Synopsis</h3>

<p>
Recently I've been writing an <a href="https://github.com/mylesalamb/TauOS">operating system</a> for my Raspbery Pi. 
Writing and running new code for the OS is typically a process of.
</p>

<ol>
        <li>writing a small change to the operating system kernel itself </li>
        <li>re-compilling the kernel</li>
        <li>mounting the SD card to the host</li>
        <li>copying the kernel over</li>
        <li>plugin the SD Card back into the Raspberry Pi and then booting it</li>
</ol>

<p>
This process is terribly manual, and really constrains the number of changes that
you can make within a particular amount of time. However, I was aware of a 
<a href="https://github.com/mrvn/raspbootin">project</a> that aims to make this process
easier, by allowing a newly compiled kernel to be transferred directly to the device, over one
of the Pi's UARTs. However, this project is designed for Raspberry Pis running in 32-bit mode,
and the implementation of the hosted section of the bootloader is in C++.
</p>

<p>
Given the aforementioned issues, I set out to create my own implementation of
both the hosted and bare metal sections of the bootloader, improving on aspects
of existing implementations as I came across issues.
</p>

<h3>Host Implementation</h3>

<p>
For the host implementation, I essentially re-wrote the program from the host
implementation in C++ to C. This helps keep the whole project easily maintainable
by myself, as I have never written much C++ myself. Albeit very basic, I decided to
improve some aspects of the host signalling to the development board, using other
control characters such as the FIN character.
</p>


<h3>Client Implementation</h3>

<p>
In other implementations of the client. The stub that is loaded by the Raspberry
Pi appears to have a rather odd limit of 2kb that is hardcoded around the 
implementation of the boot stub. I consolidated this content into a single linker
symbol, as well as implementing the assembler portion of the stub as position independant code
code, that relocates itself to the address indicated by the linker. And does an absolute jump
to the link address. The relocation that is handled by a single linker symbol is handled
<a href="https://github.com/mylesalamb/TauOS/blob/master/bootloader/client/boot.S#L17-L45">here</a>
</p>


<h3>Further work</h3>

<p>
As I continue to add more features to the system, it makes sense that for
development use the resources that can be loaded from the host system to
the development system are improved. Obvious candidates for other resources
to load over the uart, are the symbol tables generated by the tool associated with
the operating, symtab.
</p>

<p>
Even longer term it would be interesting to implement these extensions in the form of
a UART-FS driver, where an abstraction over the base driver implements file system like semantics,
being able to load arbitrary files from the host system into the development system
</p>
